# 笔记

## 缓存

### MyBatis中的一级缓存

当一个事务中发起多次同样的SQL查询时，后续将从MyBatis的缓存中读取。若非事务，则每次查询都会发起新的查询会话。

注意，一级缓存默认开启。若事务中两次相同之间涉及数据的修改，则后面几次读取的数据仍为缓存中修改前的数据，这将导致错误。解决方法：

- 可以通过配置`mybatis.configuration.local-cache-scope=statement`由默认的session改为statement，即关闭一级缓存。

### MyBatis中的二级缓存

MyBatis二级缓存中不同的 mapper, 即使操作的是同一张表，对应的缓存也是两块区域。当对同个namespace的mapper做增删改操作时，二级缓存就会清空（即使增删改的 SQL 没有改变数据， Mybatis 都会将同个命名空间下的二级缓存清空）。

MyBatis的二级缓存默认关闭。若要开启，需要：

- 相关mapper中新增`<cache></cache>`
- mapper中返回结果的实体类实现Serializable接口以序列化。当一个类需要保存起来，下次再还原成类时就需要序列化，或者需要远程传输，比如放到redis里，也需要序列化

MyBatis二级缓存缺点：

- 若涉及多读多写的场景则二级缓存近乎失效
- 二级缓存存在本地，若有多台服务器会发生数据不一致的问题

因此实际开发中很少使用MyBatis二级缓存。

### Spring内置缓存

Springboot本地缓存可以解决MyBatis二级缓存需要修改mapper的问题，但同样存在多个节点缓存不一致的问题，且缓存无过期策略，只能手动刷新。若要开启，需要：

- Spring Application上@EnableCaching

- 需要缓存的服务方法上@Cacheable

  > #### @Cacheable和@CachePut区别
  >
  > 一、相同点
  > 都是Spring的缓存注解
  >
  > 二、不同点
  > @Cacheable：只会执行一次，当标记在一个方法上时表示该方法是支持缓存的，Spring会在其被调用后将其返回值缓存起来，以保证下次利用同样的参数来执行该方法时可以直接从缓存中获取结果。
  > @CachePut标注的方法在执行前不会去检查缓存中是否存在之前执行过的结果，而是每次都会执行该方法，并将执行结果以键值对的形式存入指定的缓存中。

### Redis缓存

可通过配置`spring.cache.type=redis`参数，将Spring缓存存放到Redis上。使用 Redis 存放缓存解决了两个问题：

- 提高访问速度， mysq |单机 QPS 约为 2000 ， redis 约 10 万
- 解决多节点共享缓存，机器重启也不会丢缓存数据

Redis 常用于放用户的登录信息，早期没有 redis 时，登录信息都放在 session中，应用一重启，登录就没有了，多节点 session 又是另一个头大的问题

### 缓存相关问题

#### 缓存击穿

一个热点的Key失效后，导致大量请求直接访问数据库

解决方案：

- 针对缓存过期失效问题：
  - 设置热点数据的预热策略，预先加载或刷新缓存中的数据
- 针对数据库查询问题：
  - 使用互斥锁或分布式锁来避免多个请求同时尝试加载缺失的数据，只有一个请求去加载数据，其他请求等待或返回旧数据或快速返回失败。

#### 缓存穿透

缓存穿透是指请求一个在数据库中也不存在的数据，因此无论如何都无法在缓存中找到该数据，每次请求都会导致数据库的查询操作。缓存穿透通常是由于恶意请求或错误的请求引起的，这些请求可能是故意构造的，以请求不存在的数据，导致缓存无法起到有效的过滤作用。

解决方案：

- 针对缓存不存在问题：

  - 对于不存在的数据，可以缓存一个特殊值，以避免不断地查询数据源。比如通过设置`spring.cache.redis.cache-null-values=true`允许Spring向Redis缓存null来表示数据库中不存在该数据，和代表实际数据的[]空列表相区分。

- 针对数据库查询问题：

  使用布隆过滤器（Bloom Filter）来快速判断请求的数据是否存在于数据库中，如果布隆过滤器认为数据不存在，就不会进一步查询数据库。

#### 缓存雪崩

和缓存击穿相似，由于短时间内，大量的Key失效，导致数据库压力剧增。缓存击穿&穿透的对象是单个缓存，而缓存雪崩的对象是海量缓存。

解决方案：

- 针对缓存失效问题：
  - 设置热点数据的预热策略，预先加载或刷新缓存中的数据
  - 使用合适的过期策略，常见的有：
    - TTL超时时间
    - LRU最近最少使用
    - LFU最近最不经常使用
    - FIFO先进先出
    - Random随机淘汰策略
    - 自适应过期策略：根据访问频率和数据的重要性动态调整数据的过期时间。热门数据可以设置较长的过期时间，冷门数据可以设置较短的过期时间。
  - 针对数据库查询问题：
    - 使用互斥锁或分布式锁来避免多个请求同时尝试加载缺失的数据，只有一个请求去加载数据，其他请求等待或返回旧数据或快速返回失败。

### 缓存在高并发场景中的生产问题分享

1. 场景：每天的会员数很多，百万级别，但每个会员一天只会有几次请求，一个会员信息在同一次请求中，会被用到多次，且会员信息较大

   - 问题：多次调用查询会员方法，组装信息多，多次访问数据库

     解决：使用本地缓存，1分钟有效

   - 问题： fullgc(stop the world）频繁，导致短时间内大量请求失败

     原因：因为会员信息是大对象，一分钟内会缓存大量缓存会员信息。造成JVM中新生代内存区域数据大量增加，触发GC。又因为缓存有效期为一分钟，不会将其回收，很快新生代又满了，再次触发GC。如此反复，一分钟内新生代内存区域发生大量GC，使JVM误认为缓存为重要信息而将其移入老生代内存区域。然而老年代很快也满了，这触发了fullgc，导致大量请求失败。

     解决：取消本地缓存，改为使用线程本地变量

## Seata

### 四种事务模式

- AT 模式

  默认，简单，需要增加undo_log表，生成反向SQL ，性能高。回滚后，原来没数据的，现在还是没数据

- TCC 模式

  try confirm/cancel ，三个阶段的代码都得自己实现， Seata 只负责调度。对业务代码侵入性较强，必要时可能还要修改数据库（比如增加冻结字段）

- SAGA 模式

  长事务解决方案，需要程序员自己编写两阶段代码（AT 模式不需要写第二阶段confirm/cancel）。基于状态机来实现的，需要一个 JSON 文件，可异步执行

- XA模式

  XA 协议是由 X/Open 组织提出的分布式事务处理规范，基于数据库的XA协议来实现2PC 又称为XA方案，适用于强一致性的场景，比如金融、银行等。需要数据库本身支持XA协议，可以跨数据库。和其他三个模式不同，该模式不是每次操作都提交事务，而是最后提交一次。因此若有两个请求进入，后一个请求读取到的是第一个操作修改前的数据。



# 常见问题汇总

### generator代码生成器运行报错，找不到member中的枚举类

generator模块依赖member模块, member模块依赖common模块。所以先编译 common，再编译 member， 就可以执行generator了。

### 关于redis和mysql的一致性问题

mysql和redis的一致性，一般都是弱一致性，就是某个时间段，数据会不一致，但最终是一致的，比如余票查询，用户查的时候，列表从缓存里读，显示余票为1，但实际数据库可能是0了，但经过定时刷新缓存，最终缓存里也会变为0。

强一致性的话，几乎没法做，不适用，会有几个问题：

1. 每次有人买票，都要同时修改数据库和缓存，对于高并发抢票，就会去频繁的修改缓存，这就失去了缓存的意义，缓存应该是读多写少。
2. 比如缓存更新失败了，难道就不让用了？功能设计上，肯定是把缓存当成功能加强，而不是功能必须。缓存失败时，我们还是要能通过数据库来取数据，只不过为了防止并发过大，数据库撑不住，我们要加其它技术方案，比如限流、令牌、加锁等。
3. 一次购票中，我们想同时更新缓存和数据库，但没法做到同时，他们又不能加事务，总是有先后的，所以依然有可能出现用户查到的缓存数据和数据库不一致的情况。

所以，一般我们的用法就是弱一致性：数据读缓存，然后定期更新或条件更新缓存

### 